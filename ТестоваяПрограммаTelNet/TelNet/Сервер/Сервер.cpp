//Сервер#include <iostream>  #include <Windows.h> // Не забудьте включить заголовочный файл#include <process.h>#include <string>using namespace std;#pragma comment(lib, "WS2_32.lib")  // Отображение загрузки ws2_32.dll ws2_32.dll - последняя версия сокетаvoid Receive(void* param)		// Функция потока, принимающая данные{	while (1)	{		// Сервер принимает данные		SOCKET revClientSocket = *(SOCKET*)(param);		char recvbuf[2048] = {};		// Приемный буфер		if (recv(revClientSocket, recvbuf, 2048, 0) == SOCKET_ERROR)		{			cout << "Не удалось принять данные!" << endl;		}		else			cout << "[Клиент] сказал:" << recvbuf << endl;	}}void Send(void* param)		// Функция потока для отправки данных{	while (1)	{		// Сервер отправляет данные		SOCKET revClientSocket = *(SOCKET*)(param);		char sendbuf[2048] = {};		// Отправляем буфер		cin.getline(sendbuf, 2048);		if (send(revClientSocket, sendbuf, strlen(sendbuf), 0) == SOCKET_ERROR)		{			cout << "Не удалось отправить сообщение!" << endl;		}		else			cout << "[Я сказал:" << sendbuf << endl;	}}int main(){	cout << "----------- сервер -----------" << endl;	// Инициализация сокета	WSADATA wsaData;	// Эта структура используется для хранения данных Windows Sockets, возвращаемых после вызова функции WSAStartup.	WORD sockVersion = MAKEWORD(2, 2);	// Информация о номере версии библиотеки сетевого программирования Windows	if (WSAStartup(sockVersion, &wsaData) != 0) // Функция WSAStartup предназначена для инициализации и загрузки сети Windows в программе	{		cout << "Ошибка инициализации сокета!" << endl;		return 0;	}	// Создаем серверный сокет	SOCKET SeverSocket;	if ((SeverSocket = socket(AF_INET, SOCK_STREAM, 0)) == SOCKET_ERROR)	{		cout << "Не удалось создать сокет!" << endl;		return 0;	}	struct sockaddr_in SeverAddress;		// Адрес привязки: есть IP-адрес, номер порта и семейство протоколов	memset(&SeverAddress, 0, sizeof(sockaddr_in)); // Инициализируем структуру	SeverAddress.sin_family = AF_INET;	SeverAddress.sin_addr.S_un.S_addr = htonl(INADDR_ANY);// Заполняем локальный IP-адрес 	SeverAddress.sin_port = htons(60000);// Устанавливаем номер порта	// Привязать сокет Укажите привязанный IP-адрес и номер порта	if (bind(SeverSocket, (sockaddr*)&SeverAddress, sizeof(SeverAddress)) == SOCKET_ERROR)	{		cout << "Не удалось привязать сокет!" << endl;		return 0;	}	// Мониторинг сервера		if (listen(SeverSocket, SOMAXCONN) == SOCKET_ERROR) // Второй параметр мониторинга: сколько клиентских запросов можно сохранить, что очень полезно для параллельного программирования.	{		cout << "Сбой мониторинга!" << endl;		return 0;	}	else		cout << "Сервер слушает:" << endl;	// Сервер принимает запрос на подключение	sockaddr_in revClientAddress;	// Адрес и порт сокета	SOCKET revClientSocket = INVALID_SOCKET;		// Используется для получения клиентских подключений	//memset(&revClientAddress, 0, sizeof(revClientAddress));	int addlen = sizeof(revClientAddress);	if ((revClientSocket = accept(SeverSocket, (sockaddr*)&revClientAddress, &addlen)) == INVALID_SOCKET)	{		cout << "Не удалось принять клиентское соединение!" << endl;		return 0;	}	else		cout << "Успешно принять клиентское соединение!" << endl;	// Создаем два дочерних потока	_beginthread(Receive, 0, &revClientSocket);	_beginthread(Send, 0, &revClientSocket);	while (1) {}  // Чтобы предотвратить выход из основного потока, дочерний поток вынужден умереть, а основной поток входит в цикл	// Закрываем сокет	closesocket(revClientSocket);	closesocket(SeverSocket);	// завершение	WSACleanup();	cout << "Сервер остановлен!" << endl;	return 0;}