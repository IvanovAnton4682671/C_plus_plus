//Клиент#include <iostream>  #include <Windows.h> // Не забудьте включить заголовочный файл#include <process.h>#include <string>using namespace std;#pragma comment(lib, "WS2_32.lib")void Receive(void* param){	while (1)	{		// Клиент принимает данные с сервера		SOCKET clientSocket = *(SOCKET*)(param);		char  recvbuf[2048] = {};		// Приемный буфер		if (recv(clientSocket, recvbuf, 2048, 0) == SOCKET_ERROR)		{			cout << "Не удалось принять данные" << endl;		}		else			cout << "[Сервер] сказал:" << recvbuf << endl;	}}void Send(void* param){	while (1)	{		// Клиент отправляет данные на сервер		SOCKET clientSocket = *(SOCKET*)(param);		char sendbuf[2048] = {};		// Отправляем буфер		cin.getline(sendbuf, 2048);		if (send(clientSocket, sendbuf, strlen(sendbuf), 0) == SOCKET_ERROR)		{			cout << "Не удалось отправить сообщение!";		}		else			cout << "[Я сказал:" << sendbuf << endl;	}}int main(){	cout << "----------- Клиент -----------" << endl;	WSADATA  wsa;	if (WSAStartup(MAKEWORD(2, 2), &wsa) != 0)	{		cout << "Ошибка инициализации сокета!" << endl;	}	SOCKET clientSocket;	if ((clientSocket = socket(AF_INET, SOCK_STREAM, 0)) == SOCKET_ERROR)	{		cout << "Не удалось создать сокет!" << endl;	}	struct sockaddr_in SeverAddress;		// Адрес сервера - это целевой адрес для подключения	memset(&SeverAddress, 0, sizeof(sockaddr_in));	SeverAddress.sin_family = AF_INET;	SeverAddress.sin_addr.S_un.S_addr = inet_addr("127.0.0.1");  //127.0.0.1 представляет локальный IP-адрес	SeverAddress.sin_port = htons(60000);// Устанавливаем номер порта	// Запускаем соединение	if (connect(clientSocket, (sockaddr*)&SeverAddress, sizeof(SeverAddress)) == SOCKET_ERROR)	{		cout << "Клиент: не удалось подключиться к серверу!" << endl;		return 0;	}	else		cout << "Подключено к серверу успешно!" << endl;	// Создаем два дочерних потока	_beginthread(Receive, 0, &clientSocket);	_beginthread(Send, 0, &clientSocket);	Sleep(INFINITE);	// Здесь используется другой метод, чтобы предотвратить выход из основного потока после выполнения - заставить его спать на неопределенный срок	// Закрываем сокет	if (clientSocket != INVALID_SOCKET) {		closesocket(clientSocket);		clientSocket = INVALID_SOCKET;	}	// завершить	WSACleanup();	cout << "Клиент уходит!" << endl;	return 0;}